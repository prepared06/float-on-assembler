; ---=== ASMEdit v.3.4a       [ http://MCGusto.info ]  ===---
.MODEL SMALL
.386
.STACK 100h                  ;резервируем стек
ORG 100h

.DATA
     Y dd ?                  ;переменная для ответа
     a dd 4.5                ;переменная а
     b dd 23.56              ;переменная b
     x dd 5.23               ;переменная x
     p dd 71.3               ;переменная p
     ONE dd 1.0
     TWO dd 2.0
     MES db "( 1+ cos(5.23-4.5) ) / ( 2*23.56-71.3 ) = $"
.CODE
;вывод чисел флоат
; Требуется директива .286C или выше.
outfloat proc   near
        push    ax
        push    cx
        push    dx
; Формируем кадр стэка, чтобы хранить в нём десятку
; и ещё какую-нибудь цифру.
        push    bp
        mov     bp, sp
        push    10
        push    0
; Проверяем число на знак, и если оно отрицательное,
        ftst
        fstsw   ax
        sahf
        jnc     @of1
; то выводим минус
        mov     ah, 02h
        mov     dl, '-'
        int     21h
; и оставляем модуль числа.
        fchs
; Пояснение далее пойдёт на примере.   ; ST(0) ST(1) ST(2) ST(3) ...
; Отделим целую часть от дробной.      ; 73.25 ... что-то не наше
@of1:   fld1                           ;  1    73.25 ...
        fld     st(1)                  ; 73.25  1    73.25 ...
; Остаток от деления на единицу даст дробную часть.
        fprem                          ;  0.25  1    73.25 ...
; Если вычесть её из исходного числа, получится целая часть.
        fsub    st(2), st              ;  0.25  1    73    ...
        fxch    st(2)                  ; 73     1     0.25 ...
; Сначала поработаем с целой частью. Считать количество цифр будем в CX.
        xor     cx, cx
; Поделим целую часть на десять,
@of2:   fidiv   word ptr [bp - 2]      ;  7.3   1     0.25 ...
        fxch    st(1)                  ;  1     7.3   0.25 ...
        fld     st(1)                  ;  7.3   1     7.3   0.25 ...
; отделим дробную часть - очередную справа цифру целой части исходного числа,-
        fprem                          ;  0.3   1     7.3   0.25 ...
; от чатсного оставим только целую часть
        fsub    st(2), st              ;  0.3   1     7     0.25 ...
; и сохраним цифру
        fimul   word ptr [bp - 2]      ;  3     1     7     0.25 ...
        fistp   word ptr [bp - 4]      ;  1     7     0.25 ...
        inc     cx
; в стэке.
        push    word ptr [bp - 4]
        fxch    st(1)                  ;  7     1     0.25 ...
; Так будем повторять, пока от целой части не останется ноль.
        ftst
        fstsw   ax
        sahf
        jnz     short @of2
; Теперь выведем её.
        mov     ah, 02h
@of3:   pop     dx
; Вытаскиваем очередную цифру, переводим её в символ и выводим.
        add     dl, 30h
        int     21h
; И так, пока не выведем все цифры.
        loop    @of3                   ;  0     1     0.25 ...
; Итак, теперь возьмёмся за дробную часть, для начала проверив её существование.
        fstp    st(0)                  ;  1     0.25 ...
        fxch    st(1)                  ;  0.25  1    ...
        ftst
        fstsw   ax
        sahf
        jz      short @of5
; Если она всё-таки ненулевая, выведем точку
        mov     ah, 02h
        mov     dl, '.'
        int     21h
; и не более шести цифр дробной части.
        mov     cx, 6
; Помножим дрообную часть на десять,
@of4:   fimul   word ptr [bp - 2]      ;  2.5   1    ...
        fxch    st(1)                  ;  1     2.5  ...
        fld     st(1)                  ;  2.5   1     2.5  ...
; отделим целую часть - очередную слева цифру дробной части исходного числа,-
        fprem                          ;  0.5   1     2.5  ...
; оставим от произведения лишь дробную часть,
        fsub    st(2), st              ;  0.5   1     2    ...
        fxch    st(2)                  ;  2     1     0.5  ...
; сохраним полученную цифру во временной ячейке
        fistp   word ptr [bp - 4]      ;  1     0.5  ...
; и сразу выведем.
        mov     ah, 02h
        mov     dl, [bp - 4]
        add     dl, 30h
        int     21h
; Теперь, если остаток дробной части ненулевой
        fxch    st(1)                  ;  0.5   1    ...
        ftst
        fstsw   ax
        sahf
; и мы вывели менее шести цифр, продолжим.
        loopnz  @of4                   ;  0     1    ...
; Итак, число выведено. Осталось убрать мусор из стэка.
@of5:   fstp    st(0)                  ;  1     ...
        fstp    st(0)                  ;  ...
; Точнее, стэков.
        leave
        pop     dx
        pop     cx
        pop     ax
        ret
outfloat endp

                            ;моё задание 
                            ;                   x     a             b       P     
                            ;Y= (1+ cos(5.23-4.5))/(2*23.56-71.3)


program:
MOV AX,@DATA
MOV DS,AX
;--------------
               finit                                                   ; инициализируешь FPU
               FLD x                                                 ;добавляем в стек х
               FSUB a                                               ;отнимаем от х переменную а
               FCOS                                                 ;находим от разницы косинус
               FADD  ONE                                          ;добавляем косинусу 1

               FLD b                                                 ;добавляю в стек b      
               FMUL TWO                                          ;делю на 2           
               FSUB P                                               ;отнимаю P         
               FSTP Y                                               ;вытаскиваю получившеся значение (2*b-p)  в  Y
               FDIV Y                                                ;делю вершину стека (1+cos(x-a) ) на Y (2*b-p)
               
                                                                       ;вывод результата
PUSH DX                                                           ;сохраняем регистр DX в стеке
               LEA dx, MES;                                      ; в DX помещаем адрес строки MES
               mov ah,9;                                          ;  в регистр AH записываем номер вызова функции 
               int 21h;                                              ;вызывем вектор прерывания для ДОС
POP DX                                                             ;в DX возращаем сохраненые значения из стека
               CALL outfloat                                      ;вызываем процедуру "outfloat" которая выводит значение на экран из вершины стека

;--------------
MOV AX, 4C00H
INT 21H

END program
